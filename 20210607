1. object 클래스
☑️  특징
✔️ java.lang 패키지에 포함되어 있다
✔️ 모든 클래스의 수퍼클래스(super class) → 모든 클래스에 강제 상속 & 모든 객체가 공통으로 가지는 객체의 속성을 나타내는 메소드를 보유한다.

☑️  객체를 문자열로 변환하기
✔️ String toString() : Object 클래스에 구현된 toString()이 반환하는 문자열
※ 객체 + 문자열 ▶ 객체.toString() + 문자열 ; 객체를 문자열로 형변환하는 것이다

☑️  객체 비교와 equals()
✔️==연산자: 두 개의 레퍼런스 비교
✔️boolean equals(Object obj) : 객체 내용이 같은지 비교
★ 레퍼런스(reference)와 객체내용은 엄연히 다르다! 물론 일치할 수도 있지만, 본질적으로 다른 개념이라는 것을 기억하자


2. wrapper 클래스
Wrapper Class : 자바의 기본 타임을 클래스화한 8개의 클래스
✔️ 클래스 이름이 Wrapper가 아니다. 그냥 추상적인 개념이고, 그 안의 자바 기본타입을 클래스화한 8개의 클래스가 실체임
✔️ 기본 타입의 값을 객체로 다를 수 있게 한다.
*** Java 9부터 생성자(new)를 이용하여 Wrapper의 객체 생성하는 것이 폐기되었음 주의 

☑️  주요메소드
✔️ wrapper 객체들은 거의 유사하고, 많은 메소드가 static 타입이다
+++ static이란?

JAVA Static이란?
static 예약어를 사용하면 인스턴스를 생성하기 전에 미리 메모리에 올려놔 고정시킨다.
1. 인스턴스를 생성한 후 이용가능 하던 변수가 static 예약어를 사용함으로써, 미리 메모리에 올라가 있으므로, 인스턴스 생성 없이 바로 사용가능하다.

2. StaticTest 의 인스턴스를 몇개를 생성하든 a의 변수는 이미 메모리에 올라가 있으므로, 인스턴스 마다 변수 a가 생기는 것이 아니라 메모리에 미리 올라가 있던 변수 a를 공유한다. →  static 예약어를 사용한 변수는 공유변수 라고도 불린다.
✔️ 변수a를 공유하므로 변수a크기 만큼 메모리를 아낄 수 도 있다. 
✔️ 메서드도 마찬가지로 메모리를 아낄 수 있음

3. 만약 변수b를 static 메서드 add안에다가 사용하면 오류가 발생한다. 
이유는 int b는 StaticTest의 인스턴스가 생성되어야 쓸수 있는 멤버변수지만, static public void add()는 인스턴스가 생기길 기다려주지 않고 바로 메모리에 올라가기 때문에 StaticTest안에 일반 멤버변수 b는 쓰지 못한다.
→ 애초에 전제조건이 달라서 그렇다. 어떤 요소는 인스턴스가 생성됨을 전제로 하고, 나머지는 인스턴스 생성이라는 과정을 거치지 않고 바로 메모리에 올라가기 때문에 에러가 발생한다. 

☑️ 활용
✔️ wrapper 객체로부터 기본 타입 값을 알아낼 수 있다
✔️ 문자열을 기본 데이터 타입으로 변환한다
✔️ 기본타입을 문자열로 변환한다

☑️ 박싱(boxing)과 언박싱(unboxing)
✔️박싱(boxing) : 기본 타입의 값을 Wrapper 객체로 변환한다
✔️언박싱(unboxing) : Wrapper 객체에 들어있는 기본 타입의 값을 빼내는 것


3. String 클래스

특징과 객체 생성
✔️String 클래스는 하나의 문자열을 표현한다
✔️스트링 리터럴과 new String()

스트링 생성방법
✔️리터럴로 생성 : JVM이 리터럴 관리, 응용프로그램 내에서 공유된다

☑️ 제네릭(Generic)

제네릭 프로그래밍(generic programming) : 일반적인 코드를 작성하고, 이 코드를 다양한 타입의 객체에 대하여 재사용하는 프로그래밍


컴파일 단계에서 잘못된 타입을 사용할 수 있는 문제를 제거할 수 있다

 

☑️ 제네릭을 사용하는 이유

컴파일 시 강한 타입 체크가 가능

-클래스들의 구조와 연결관계의 복잡성 증가 → 타입오류발생 (ex TypeMisscasting)

-실행시 런타임-타임에러 발생 방지

-컴파일 하기 전 미리 타입을 강하게 체크하여 에러 발생을 막아준다

 

☑️ 제네릭 타입

타입을 파라미터로 가지는 클래스(Class)와 인터페이스(interface)

선언 시 클래스 또는 인터페이스 이름 뒤에 "<>" 부호 붙인다. (* 낯설 수 있으니 주의)

타입 파라미터

- 일반적으로 대문자 알파벳 한 문자로 표현하다

- 개발 코드에서는 타입 파라미터 자리에 구체적인 타입을 지정한다.

 

☑️ 제네릭 메소드

매개변수 타입과 리턴 타입으로 타입 파라미터를 갇는 메소드 

제네릭 메소드 선언 방법 : 리턴 타입 앞에 "<>" 기호를 추가하고 타입 파라미터 기술

 

☑️ 와일드카드 타입

? : 와일드카드 타입의 세 가지 형태 : 매개변수에서 허용한다.

제네릭타입<?> : Unbounded Wildcards : 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.

제네릭타입<?extends 상위타입> : Upper Bounded Wildcards → 상위클래스 제한

: 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위타입만 올 수 있다.

제네릭타입<?super 하위타입> : Lower Bounded Wildcards → 하위클래스 제한

: 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위타입만 올 수 있다.

 

☑️ 제네릭 타입의 상속과 구현

제네릭 타입을 부모 클래스로 사용하려면?

타입 파라미터는 자식클래스에서도 기술해야 한다 + 추가적인 타입 파라미터 가질 수 있다.

제네릭 인터페이스를 구현한 경우 구현한 클래스도 제네릭 타입이다.

 
